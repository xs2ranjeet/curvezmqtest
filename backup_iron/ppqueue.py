#
##  Paranoid Pirate queue
#
#   Author: Daniel Lundin <dln(at)eintr(dot)org>
#

from collections import OrderedDict
import logging
import os
import sys
import time

import zmq
import zmq.auth
from zmq.auth.thread import ThreadAuthenticator

HEARTBEAT_LIVENESS = 3     # 3..5 is reasonable
HEARTBEAT_INTERVAL = 1.0   # Seconds

#  Paranoid Pirate Protocol constants
PPP_READY = "\x01"      # Signals worker is ready
PPP_HEARTBEAT = "\x02"  # Signals worker heartbeat


class Worker(object):
    def __init__(self, address):
        self.address = address
        self.expiry = time.time() + HEARTBEAT_INTERVAL * HEARTBEAT_LIVENESS

class WorkerQueue(object):
    def __init__(self):
        self.queue = OrderedDict()

    def ready(self, worker):
        self.queue.pop(worker.address, None)
        self.queue[worker.address] = worker
    def next(self):
        address, worker = self.queue.popitem(False)
        print(address)
        print(worker)
        return address

def run():
    ''' Run Ironhouse test '''
    # These directories are generated by the generate_certificates script
    base_dir = os.path.dirname(__file__)
    keys_dir = os.path.join(base_dir, 'certificates')
    public_keys_dir = os.path.join(base_dir, 'public_keys')
    secret_keys_dir = os.path.join(base_dir, 'private_keys')

    if not (os.path.exists(keys_dir) and
            os.path.exists(public_keys_dir) and
            os.path.exists(secret_keys_dir)):
        logging.critical("Certificates are missing: run generate_certificates.py script first")
        sys.exit(1)
    
    context = zmq.Context(1)
    # Start an authenticator for this context.
    auth = ThreadAuthenticator(context)
    auth.start()
    auth.allow()
    #auth.allow('127.0.0.1')
    #auth.allow('192.168.232.128')
    ## Tell the authenticator how to handle CURVE requests
    #auth.configure_curve(domain='*', location=zmq.auth.CURVE_ALLOW_ANY)
    
    # Tell authenticator to use the certificate in a directory
    auth.configure_curve(domain='*', location=public_keys_dir)
    
    backend = context.socket(zmq.ROUTER)  # ROUTER
    server_secret_file = os.path.join(secret_keys_dir, "server.key_secret")
    server_public, server_secret = zmq.auth.load_certificate(server_secret_file)
    backend.curve_secretkey = server_secret
    backend.curve_publickey = server_public
    backend.curve_server = True  # must come before bind
    backend.bind("tcp://*:5556")  # For workers
    
    poll_workers = zmq.Poller()
    poll_workers.register(backend, zmq.POLLIN)
    
    workers = WorkerQueue()
    heartbeat_at = time.time() + HEARTBEAT_INTERVAL
    
    while True:
        poller = poll_workers
        socks = dict(poller.poll(HEARTBEAT_INTERVAL * 1000))
    
        # Handle worker activity on backend
        if socks.get(backend) == zmq.POLLIN:
            # Use worker address for LRU routing
            frames = backend.recv_multipart()
            if not frames:
                break
            logging.info(frames)
            address = frames[0]
            workers.ready(Worker(address))
            #print(address)
            msg = [address, b'Gopinath']
            backend.send_multipart(msg)
            # Send heartbeats to idle workers if it's time
        if time.time() >= heartbeat_at:
            for worker in workers.queue:
                msg = [worker, b'PPP_HEARTBEAT']
                logging.info('About to send HB {}'.format(worker))
                backend.send_multipart(msg)
            heartbeat_at = time.time() + HEARTBEAT_INTERVAL
    
if __name__ == '__main__':
    if zmq.zmq_version_info() < (4,0):
        raise RuntimeError("Security is not supported in libzmq version < 4.0. libzmq version {0}".format(zmq.zmq_version()))

    if '-v' in sys.argv:
        level = logging.DEBUG
    else:
        level = logging.INFO    
    logging.basicConfig(level=level, format="[%(levelname)s] %(message)s")
    run()
    