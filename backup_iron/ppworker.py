#
##  Paranoid Pirate worker
#
#   Author: Daniel Lundin <dln(at)eintr(dot)org>
#

from random import randint
import logging
import os
import sys
import time

import zmq
import zmq.auth
from zmq.auth.thread import ThreadAuthenticator

HEARTBEAT_LIVENESS = 3
HEARTBEAT_INTERVAL = 1
INTERVAL_INIT = 1
INTERVAL_MAX = 32

#  Paranoid Pirate Protocol constants
PPP_READY = "\x01"      # Signals worker is ready
PPP_HEARTBEAT = "\x02"  # Signals worker heartbeat

def worker_socket(context, poller):
    """Helper function that returns a new configured socket
       connected to the Paranoid Pirate queue"""
    worker = context.socket(zmq.DEALER) # DEALER
    identity = 'ranjeet'#"%04X-%04X" % (randint(0, 0x10000), randint(0, 0x10000))
    worker.setsockopt_string(zmq.IDENTITY, identity)
    poller.register(worker, zmq.POLLIN)
#    worker.connect("tcp://192.168.232.129:5556")
    worker.connect("tcp://192.168.1.165:5556")
    worker.send_string('PPP_READY')
    return worker


def run():
    # These directories are generated by the generate_certificates script
    base_dir = os.path.dirname(__file__)
    keys_dir = os.path.join(base_dir, 'certificates')
    public_keys_dir = os.path.join(base_dir, 'public_keys')
    secret_keys_dir = os.path.join(base_dir, 'private_keys')

    if not (os.path.exists(keys_dir) and
            os.path.exists(public_keys_dir) and
            os.path.exists(secret_keys_dir)):
        logging.critical("Certificates are missing: run generate_certificates.py script first")
        sys.exit(1)

    
    context = zmq.Context(1)
    # Start an authenticator for this context.
    auth = ThreadAuthenticator(context)
    auth.start()
    auth.allow()
    #auth.allow('192.168.232.129')
    ## Tell the authenticator how to handle CURVE requests
    #auth.configure_curve(domain='*', location=zmq.auth.CURVE_ALLOW_ANY)
    # Tell authenticator to use the certificate in a directory
    auth.configure_curve(domain='*', location=public_keys_dir)

    worker = context.socket(zmq.DEALER) # DEALER
    # We need two certificates, one for the client and one for
    # the server. The client must know the server's public key
    # to make a CURVE connection.
    client_secret_file = os.path.join(secret_keys_dir, "client.key_secret")
    client_public, client_secret = zmq.auth.load_certificate(client_secret_file)
    worker.curve_secretkey = client_secret
    worker.curve_publickey = client_public

    # The client must know the server's public key to make a CURVE connection.
    server_public_file = os.path.join(public_keys_dir, "server.key")
    server_public, _ = zmq.auth.load_certificate(server_public_file)
    # The client must know the server's public key to make a CURVE connection.
    worker.curve_serverkey = server_public

    poller = zmq.Poller()

    identity = 'ranjeet'#"%04X-%04X" % (randint(0, 0x10000), randint(0, 0x10000))
    worker.setsockopt_string(zmq.IDENTITY, identity)
    poller.register(worker, zmq.POLLIN)
    worker.connect("tcp://192.168.1.165:5556")
    worker.send_string('PPP_READY')

    
    liveness = HEARTBEAT_LIVENESS
    interval = INTERVAL_INIT
    
    heartbeat_at = time.time() + HEARTBEAT_INTERVAL
    
    #worker = worker_socket(context, poller)
    cycles = 0
    while True:
        socks = dict(poller.poll(HEARTBEAT_INTERVAL * 1000))
    
        # Handle worker activity on backend
        if socks.get(worker) == zmq.POLLIN:
            frames = worker.recv_multipart()
            if not frames:
                break # Interrupted
            logging.info(frames)
        if time.time() > heartbeat_at:
            heartbeat_at = time.time() + HEARTBEAT_INTERVAL
            #print ("I: Worker heartbeat")
            worker.send_string('PPP_HEARTBEAT')
    auth.stop()
    
if __name__ =='__main__':
    if zmq.zmq_version_info() < (4,0):
        raise RuntimeError("Security is not supported in libzmq version < 4.0. libzmq version {0}".format(zmq.zmq_version()))

    if '-v' in sys.argv:
        level = logging.DEBUG
    else:
        level = logging.INFO    
        
    logging.basicConfig(level=level, format="[%(levelname)s] %(message)s")
    run()    